<!DOCTYPE html>
<!--
Link: https://thomasyicui.github.io/Survive/
This was made by How-Code? (Also known as Code247)
CONTROLS: 
    -Number pad to switch items
    -WASD or Arrow keys to move
Change Log:
    April 10 2022 || Version 0.05
        -added blocks (not fineshed yet)
        -add block building (not fineshed yet)
        -made a 15 cap for building blocks
        (I will work on stone and mateirals next and school will slow down progress)
    April 11 2022|| Version 0.09
        -added so if you hit tree of stone you get the matierial
        -added so you can heal with the apple: +20 hp -10 food
        -added so when you build it uses 10 wood
        -pressing space uses the tool
        -added bush, you can hit it to get food.
        -added food display
        -added a grid pattern
    April 12 2022|| Version 0.1
        -fized collision (thanks to Dominic R.)
        -added exp and agging (you get exp for getting matierials)
        -added gold and stoen display
        -remade stone graphics from a circle to a heptagon
        -remade bush graphics added berries and changed shape
        -added gold ore you can hit it to get gold
    April 13 2022|| Version 0.2
        -added wolves
        -wolves now move even if you can't see them
        -wolves collide with trees (I NEED SOMEONE TO FIX THE COLLISION)
        -wolves collide with stone (I NEED SOMEONE TO FIX THE COLLISION)
        -wolves collide with gold (I NEED SOMEONE TO FIX THE COLLISION)
    April 14 2022|| Version 0.25
        -You can now do damage to wolves
        I will be competing so progross will be slow or will stop entiraly.
    April 20 2022|| Version 0.3
        I got back and I will get to work
        -Wolves follow you and attack you
        -You get food for killing wolves
        -Fixed the wolves hit boxes
        -Started work on menu
    April 21 2022|| Version 0.375
        -Wolves have a name
        -Wolves have a helath bar
        -Menu got updated
        -Added Level System
        -Added Spear [Wepon]
        -Fixed wepon colision
        Started planning things with Milanote
    April 22 2022|| Version 0.45
        -Added Sword
        -Made wepons rotate and fit in the box
        -Added stone block
        -You can build with stone block
        -Added cookie
        -Blocks now collide with you
        -Blocks now collide with wolves
        Found Glitch that you get age 3 stuff even though you are at age 2 [FIXED]
        -Started cleaning code
    April 23 2022|| Version 0.7
        -Objects have hp
        -You can delete objects by hitting it
        -Added milita soldier graphics
        -Soldiers follow you
        -Soldiers hit and collide with wolves, trees, stone, bushes, and blocks
        -Soldiers can die
        -Made barracks a block
        -If you place barracks it spawn a soldier
    April 24 2022|| Version 1.1
        -Fixed bugs
        -You can get a manor which gives you tier 2 soldiers called squires
        -Stopped game from crashing sometimes
        -You can choose player color
        -Added orc genaral
        -Added orcs
        -Orcs follow orc genaral
        -Orcs collide with stuff
        -Orc groups usually spawn more milta then better orcs
    April 25 2022|| Version 1.2
        -Orc groups have a random number of orcs (more 15 then 1)
        -Wolfs drop 200 gold
        -Added a blank slate for the shop
    April 26 2022|| Version 1.25
        -Added healer hat
        -Added soldier helmet
    April 27 2022|| Version 1.26
        -Re did the menu screen
    April 28 2022|| Version 1.265
        -Change game title
    April 29 2022|| Version 1.265
        Nothing
    April 30 2022|| Version 1.3
        -Made title screen compatible with full screen
        -changed ground color
        -You can change you name
    May 1 2022|| Version 1.35
        -Added a bull
        -Changed spawn point of the wolves
        -Changed spawn point of the orcs
        I got a dog so I wont do much today
    May 9 2022|| Version 1.45
        Took a break will now start working
        -cleaned code
        -bulls respawn
        -added particles
        -added dashing
    May 10 2022|| Version 1.6
        -removed dashing
        -remade axe into one handed wepon
        -remade spear into one handed wepon
        -remade sword into one handed wepon
        -added shield
        -made it so if you press q you use shield to block
        -made axe into the center of the box AGAIN
        -made spear into the center of the box AGAIN
        -made sword into the center of the box AGAIN
        -display player name below the player
        -updated the Change log so there are versions
        -Fixed bugs
-->
<html>
    <head>
        <meta charset="utf-8">
        <title>Game</title>
        <style>
            body {
                position: fixed;
            }
            #canvi {
                margin: -10px;
            }
        </style>
    </head>
<body>
    <canvas id="canvi"></canvas>
    <script>
        // makes it more like javascript
        var canvas = document.getElementById("canvi");
        var ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        var mouseX = 0;
        var mouseY = 0;
        var clicked = false
        var keys = [];
        canvas.addEventListener("mousemove", function(e) {
            var cRect = canvas.getBoundingClientRect();
            mouseX = Math.round(e.clientX - cRect.left);
            mouseY = Math.round(e.clientY - cRect.top);
        });
        canvas.addEventListener("mousedown", function(e) {
            dragged = true;
        }, false);
        canvas.addEventListener("mouseup", function(e) {
            if(dragged === true) {
                clicked = true;
                dragged = false;
            }
        });
        window.addEventListener("keydown", keysPressed, false);
        window.addEventListener("keyup", keysReleased, false);
        function keysPressed(e) {
            // store an entry for every key pressed
            keys[e.keyCode] = true;
            e.preventDefault();
        }
        function keysReleased(e) {
            // mark keys that were released
            keys[e.keyCode] = false;
        }
        function cos(r) {
            return Math.cos(r);
        }
        function sin(r) {
            return Math.sin(r);
        }
        function atan2(y, x) {
            return Math.atan2(y, x);
        }
        function round(num) {
            return Math.round(num);
        }
        function random(min, max) {
            return min + Math.random(0, 1) * (max - min);
        }
        function dist(x, y, x2, y2) {
            var a = x - x2;
            var b = y - y2;
            return Math.sqrt(a * a + b * b);
        }
        function text(txt, x, y, size) {
            ctx.font = size + "px Arial";
            ctx.fillText(txt, x, y);
        }
        function fill(r, g, b, a) {
            if(a === undefined) {
                a = 1;
            }
            ctx.fillStyle = "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
        }
        function stroke(r, g, b) {
            ctx.strokeStyle = "rgb(" + r + ", " + g + ", " + b + ")";
        }
        function rect(x, y, w, h, r) {
            ctx.save();
            ctx.translate(x, y)
            ctx.rotate(r);
            ctx.fillRect(0, 0, w, h);
            ctx.restore();
        }
        function strokeWeight(s) {
            ctx.lineWidth = s;
        }
        function eRect(x, y, w, h, col) {
            ctx.beginPath();
            stroke(col[0], col[1], col[2]);
            ctx.rect(x, y, w, h);
            ctx.stroke();
        }
        function start() {
            var myVar = setInterval(draw, 1);
        }
        function textAlign(align) {
            ctx.textAlign = align;
        }
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }
        function dist2(a, b, d) {
            return (a - b) > -d && (a - b) < d;
        }
        function ellipse(x, y, radiusX, radiusY, rotation) {
            ctx.beginPath();
            ctx.ellipse(x, y, radiusX, radiusY, rotation, 0, 2 * Math.PI);
            ctx.fill();
        }
        function eEllipse(x, y, radiusX, radiusY, rotation) {
            ctx.beginPath();
            ctx.ellipse(x, y, radiusX, radiusY, rotation, 0, 2 * Math.PI);
            ctx.stroke();
        }
        function constrain(num, m, ma) {
            if(num < m) {
                num = m;
            } else if(num > ma) {
                num = ma;
            }
            return num;
        }
    </script>
    <script>
// Set up
textAlign("center");
// Global varibles
var scene = "menu"; // scene control
var entitys = 0; // counts the entity
var player = ""; // player
var orcGeneral = ""; // orc general
var keyPress = 10; // limit space key presses
var trees = []; // tree list
var rocks = []; // rock list
var wolves = []; // wolf list
var bulls = []; // bull list
var golds = []; // gold list
var bushes = []; // bush list
var objects = []; // object list
var soldiers = []; // soldier list
var orcs = []; // orc soldier list
var particles = []; // particle list
var blockStats = {
    woodBlock: {
        size: [25, 25],
        hp: 380,
        gives: [10, 0, 0, 0]
    },
    stoneBlock: {
        size: [25, 25],
        hp: 900,
        gives: [0, 20, 0, 0]
    },
    barracks: {
        size: [25, 50],
        hp: 400,
        gives: [250, 250, 250, 200]
    },
    manor: {
        size: [25, 50],
        hp: 600,
        gives: [350, 300, 300, 250]
    }
}; // stats of all the blocks
var alphebet = "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z".split(","); // alphebet for typing

// Misc. functions
function drawItems(x, y, inv, i) {
    ctx.save();
    if(inv[i][0] === "axe") {
        fill(100, 75, 0);
        rect(x - 37, y + 4, 40, 5, 0.25);
        fill(125, 125, 125);
        rect(x - 30, y - 12, 15, 25, 0.25);
    } else if(inv[i][0] === "spear") {
        fill(100, 75, 0);
        rect(x - 45, y + 11, 60, 5, 0);
        fill(125, 125, 125);
        rect(x - 40, y + 7, 10, 10, 45)
    } else if(inv[i][0] === "sword") {
        fill(100, 75, 0);
        rect(x - 33, y + 13, 40, 5, 0);
        fill(125, 125, 125);
        rect(x - 35.5, y + 10, 18, 10, 0);
        rect(x - 35, y + 10, 7, 7, 45);
    } else if(inv[i][0] === "apple") {
        fill(255, 10, 10);
        ellipse(x - 25, y, 10, 10, 0)
        fill(100, 75, 0);
        rect(x - 32, y - 11, 7, 2, 1)
    } else if(inv[i][0] === "cookie") {
        fill(158, 74, 0);
        ellipse(x - 25, y, 10, 10, 0);
        fill(100, 40, 0);
        ellipse(x - 21, y - 4, 2, 2, 0);
        ellipse(x - 27.5, y + 1.5, 2, 2, 0);
        ellipse(x - 29, y - 2.5, 2, 2, 0);
        ellipse(x - 22, y + 3, 2, 2, 0);
    } else if(inv[i][0] === "barracks") {
        fill(100, 75, 0);
        rect(x - 30, y - 0, 5, 20, 0);
        fill(255, 255, 255);
        for(var i = 0; i < 6; i+=1) {
            rect(x - 40 + Math.floor(i/3) * 12, y - 35 + i % 3 * 10 - Math.floor(i/3) * 10 + 25, 17, 5, -0.6 + Math.floor(i/3) * 1.2)
        }
        fill(0, 100, 255);
        for(var i = 0; i < 6; i+=1) {
            rect(x - 40 + Math.floor(i/3) * 12, y - 30 + i % 3 * 10 - Math.floor(i/3) * 10 + 25, 17, 5, -0.6 + Math.floor(i/3) * 1.2)
        }
    } else if(inv[i][0] === "manor") {
        fill(100, 75, 0);
        rect(x - 45, y - 20, 30, 40);
        fill(125, 100, 25);
        for(var i = 0; i < 5; i+=1) {
            rect(x - 45, y - 20 + i * 8, 30, 4);
        }
    } else if(inv[i][0] === "woodBlock") {
        fill(150, 100, 0);
        rect(x - 45, y - 15, 30, 30, 0);
    } else if(inv[i][0] === "stoneBlock") {
        fill(150, 150, 150);
        rect(x - 45, y - 15, 30, 30, 0);
    }
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.restore();
};
function rectToRect(x, y, w, h, x2, y2, w2, h2) {
    return x < x2 + w2 &&
        x + w > x2 &&
        y < y2 + h2 &&
        h + y > y2
};
function heptagon(x, y, r) {
    var a = 2 * Math.PI / 7;
    ctx.beginPath();
    for (var i = 0; i < 7; i++) {
        ctx.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));
    }
    ctx.closePath();
    ctx.fill();
};
function grid() {
    // the ground
    fill(0, 174, 33);
    rect(0, 0, canvas.width, canvas.height)
    // the lines
    fill(0, 0, 0, 0.1)
    for(var y = -25; y < canvas.height + 25; y+=25) {
        rect(0, y - player.y % 50, canvas.width, 2, 0);
    }
    for(var x = -25; x < canvas.width + 25; x+=25) {
        rect(x - player.x % 50, 0, 2, canvas.height, 0);
    }
};
function randomGuy() {
    var choose = round(random(0, 100));
    if(choose < 75) {
        return "milita";
    } else if(choose <= 100) {
        return "squire";
    }
};
function baisedRandom() {
    var choose = round(random(0, 225))
    for(var i = 0; i < 15; i+=1) {
        if(choose < (i * i)) {
            return i;
        }
    }
    return 15;
};

// Player functions
function Player() {
    // position of the player
    this.x = round(random(-4000, 4000));
    this.y = round(random(-4000, 4000));
    // acceleration of the player
    this.accelerationX = 0;
    this.accelerationY = 0;
    // rotation of the player
    this.r = atan2(canvas.height/2 - mouseY, canvas.width/2 - mouseX);
    this.color = [255, 200, 100];
    this.inv = [["axe", "wepon"], ["apple", "food"], ["barracks", "block"], ["woodBlock", "block"]];
    this.holding = 0;
    this.s = 10;
    this.stone = 0;
    this.wood = 0;
    this.food = 0;
    this.gold = 6000;
    this.offset = [0, 0];
    this.offsetA = [0, 0];
    this.weponSize = 10;
    this.weponLength = 30;
    this.weponDamage = 25;
    this.hp = 100;
    this.maxHp = 100;
    this.exp = 0;
    this.lvl = 1;
    this.armor = 0; // how much armor the player has
    // used for upgrading age, LVL Till end of upgrade, LVL so far
    this.upgrade = [1, 0.1];
    // toggle shop off and on
    this.showShop = false;
    // what hat the player is wearing
    this.playerHat = "none";
    // the name of the player
    this.playerName = "player";
};
Player.prototype.update = function() {
    // update the level and xp
    if(this.exp >= ((this.lvl + (this.lvl + 1)) * 32.5)) {
        this.lvl+=1;
        this.exp = 0;
        this.upgrade[0]+=1;
    }
    // update the player positions
    if(keys[87] || keys[38]) {
        this.y-=1;
    }
    
    if(keys[83] || keys[40]) {
        this.y+=1;
    }
    
    if(keys[65] || keys[37]) {
        this.x-=1;
    }
    
    if(keys[68] || keys[39]) {
        this.x+=1;
    }
    this.x+=this.accelerationX;
    this.y+=this.accelerationY;
    this.accelerationX*=0.95;
    this.accelerationY*=0.95;
    // the offset that the player holds his wepon at
    if(this.offset[0] > 0) {
        this.offsetA[0]-=0.01;
    } else {
        this.offset[0] = 0;
        this.offsetA[0] = 0;
    }
    // the offset that the player holds his 2nd thing at
    if(this.offset[1] < 0) {
        this.offsetA[1]+=0.01;
    } else {
        this.offset[1] = 0;
        this.offsetA[1] = 0;
    }
    this.offset[0]+=this.offsetA[0];
    this.offset[1]+=this.offsetA[1];
    // confine the play in a -4000 to 4000 square
    this.x = constrain(this.x, -4000, 4000);
    this.y = constrain(this.y, -4000, 4000);
    // misc stuff
    this.r = atan2(canvas.height/2 - mouseY, canvas.width/2 - mouseX);
    this.timeSinceLastPress+=1;
    this.timeSinceLastDash+=1;
};
Player.prototype.draw = function() {
    fill(this.color[0], this.color[1], this.color[2]);
    ellipse(canvas.width/2, canvas.height/2, 10, 10, 0);
    ellipse(canvas.width/2 - cos(this.r + this.offset[1] + 1) * 17.5, canvas.height/2 - sin(this.r + this.offset[1] + 1) * 17.5, 5, 5, 0);
    ellipse(canvas.width/2 - cos(this.r + this.offset[0] - 1) * 17.5, canvas.height/2 - sin(this.r + this.offset[0] - 1) * 17.5, 5, 5, 0);
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.rotate(this.r + this.offset[1]);
    fill(100, 100, 100);
    rect(-30, -17.5, 40, 5, 0);
    ctx.restore();
    fill(50, 50, 50);
    rect(canvas.width/2 - 15, canvas.height/2 + 15, 30, 5)
    fill(250, 0, 0);
    rect(canvas.width/2 - 15, canvas.height/2 + 15, (30/this.maxHp) * this.hp, 5);
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.rotate(this.r + this.offset[0]);
    drawItems(0, 0, this.inv, this.holding);
    ctx.restore();
    switch(this.playerHat) {
        case "none":
            
        break;
        case "healingHelmet":
            // draw the healing helmet
            fill(130, 130, 130);
            ellipse(canvas.width/2, canvas.height/2, 10, 10, 0);
            fill(255, 255, 255);
            ellipse(canvas.width/2, canvas.height/2, 7, 7, 0);
            fill(255, 0, 0);
            rect(canvas.width/2 - 6, canvas.height/2 - 1.5, 12, 3, 0);
            rect(canvas.width/2 - 1.5, canvas.height/2 - 6, 3, 12, 0);
        break;
        case "soldierHelmet":
            // draw the healing helmet
            fill(130, 130, 130);
            ellipse(canvas.width/2, canvas.height/2, 10, 10, 0);
            fill(132, 132, 132);
            ellipse(canvas.width/2, canvas.height/2, 6, 6, 0);
            fill(125, 125, 125);
            rect(canvas.width/2 - cos(this.r) * 7, canvas.height/2 - sin(this.r) * 6.25, 14, 3, this.r);
            this.armor = 12.5;
        break;
    }
    fill(255, 255, 255);
    text(this.playerName, canvas.width/2, canvas.height/2 + 35, 15)
};
Player.prototype.ui = function() {
    for(var i = 0; i < this.inv.length; i+=1) {
        fill(0, 0, 0, 0.1);
        rect(canvas.width/2 - (this.inv[0].length * 25) + i * 60 - 10, canvas.height - 60, 50, 50);
        if(keys[49 + i]) {
            this.holding = i;
        }
        if(this.inv[i][1] === "wepon") {
            ctx.save();
            ctx.translate(canvas.width/2 - (this.inv[0].length * 25) + i * 60 + 45, canvas.height - 35);
            if(this.inv[i][0] === "spear") {
                ctx.scale(0.85, 0.85);
                ctx.translate(-55, -5)
                ctx.rotate(3.8);
                drawItems(0, 0, this.inv, i);
            } else if(this.inv[i][0] === "axe") {
                ctx.translate(-5, 5);
                ctx.rotate(0.8);
                drawItems(0, 0, this.inv, i);
            } else if(this.inv[i][0] === "sword") {
                ctx.translate(-5, 5)
                ctx.rotate(1.9);
                drawItems(0, 0, this.inv, i);
            }
            ctx.restore();
        } else {
            drawItems(canvas.width/2 - (this.inv[0].length * 25) + i * 60 + 45, canvas.height - 35, this.inv, i);
        }
    }
    if(this.upgrade[0] > 1 && this.upgrade[1] < 1) {
            fill(0, 0, 0, 0.5);
            button(canvas.width/2 - 75, 10, 50, 50, function() {
                for(var i = 0; i < player.inv.length; i+=1) {
                    if(player.inv[i][1] === "") {
                        //player.inv[i][0] = "daggers";
                        //player.weponSize = 7.5;
                        //player.weponLength = 10;
                        //player.weponDamage = 10;
                    }
                }
                //player.upgrade[0]+=1;
                //player.upgrade[1]+=0.5;
            }, ["", 10]);
            fill(0, 0, 0, 0.5);
            button(canvas.width/2 - 15, 10, 50, 50, function() {
                for(var i = 0; i < player.inv.length; i+=1) {
                    if(player.inv[i][1] === "wepon") {
                        player.inv[i][0] = "spear";
                        player.weponSize = 7.5;
                        player.weponLength = 70;
                        player.weponDamage = 45;
                    }
                }
                player.upgrade[1]+=1;
            }, ["Spear", 10]);
            fill(0, 0, 0, 0.5)
            button(canvas.width/2 + 50, 10, 50, 50, function() {
                for(var i = 0; i < player.inv.length; i+=1) {
                    if(player.inv[i][1] === "wepon") {
                        player.inv[i][0] = "sword";
                        player.weponSize = 12;
                        player.weponLength = 40;
                        player.weponDamage = 35;
                    }
                }
                player.upgrade[1]+=1;
            }, ["Sword", 10]);
    } else if(this.upgrade[0] > 2 && this.upgrade[1] < 2) {
            fill(0, 0, 0, 0.5)
            button(canvas.width/2 + 20, 10, 50, 50, function() {
                for(var i = 0; i < player.inv.length; i+=1) {
                    if(player.inv[i][1] === "food") {
                        player.inv[i][0] = "cookie";
                    }
                }
                player.upgrade[1]+=1;
            }, ["Cookie", 10]);
            fill(0, 0, 0, 0.5)
            button(canvas.width/2 - 45, 10, 50, 50, function() {
                for(var i = 0; i < player.inv.length; i+=1) {
                    if(player.inv[i][0] === "woodBlock") {
                        player.inv[i][0] = "stoneBlock";
                    }
                }
                player.upgrade[1]+=1;
            }, ["Stone Wall", 10]);
    } else if(this.upgrade[0] > 3 && this.upgrade[1] < 3) {
        fill(0, 0, 0, 0.5)
        button(canvas.width/2 - 25, 10, 50, 50, function() {
            for(var i = 0; i < player.inv.length; i+=1) {
                if(player.inv[i][0] === "barracks") {
                    player.inv[i][0] = "manor";
                }
            }
            player.upgrade[1]+=1;
        }, ["Manor", 10]);
    }
    fill(0, 0, 0, 0.1)
    rect(canvas.width - 110, canvas.height - 40, 100, 30);
    rect(canvas.width - 110, canvas.height - 80, 100, 30);
    rect(canvas.width - 110, canvas.height - 120, 100, 30);
    rect(canvas.width - 110, canvas.height - 160, 100, 30);
    // text for matierials
    fill(255, 255, 255);
    text(this.wood, canvas.width - 50, canvas.height - 100, 20);
    text(this.gold, canvas.width - 50, canvas.height - 140, 20);
    text(this.stone, canvas.width - 50, canvas.height - 60, 20);
    text(this.food, canvas.width - 50, canvas.height - 20, 20);
    // display for matierials
    drawItems(canvas.width - 70, canvas.height - 22.5, this.inv, 1);
    fill(100, 100, 100);
    heptagon(canvas.width - 95, canvas.height - 65, 12);
    fill(255, 200, 0);
    heptagon(canvas.width - 95, canvas.height - 145, 12);
    // age
    fill(100, 100, 100);
    rect(canvas.width/2 - 150, canvas.height - 80, 300, 15);
    fill(255, 255, 255);
    rect(canvas.width/2 - 149, canvas.height - 79, (298/((this.lvl + (this.lvl + 1)) * 32.5)) * this.exp, 13)
    fill(255, 255, 255);
    text("Age: " + this.lvl, canvas.width/2, canvas.height - 85);
    // shop button
    fill(0, 0, 0, 0.5)
    button(canvas.width - 35, 10, 25, 25, function() {
        player.showShop = !player.showShop;
    }, ["🛒", 15]);
    // if we should show shop
    if(this.showShop) {
        // show shop
        fill(0, 0, 0, 0.5);
        rect(canvas.width/8, 35, canvas.width - canvas.width/4, canvas.height - 40, 0);
        fill(255, 255, 255);
        text("Shop", canvas.width/2, 75, canvas.height/8.88889);
        fill(0, 0, 0, 0.5);
        button(canvas.width/8, canvas.height/4.44444, canvas.width - canvas.width/4, (canvas.height - 40)/8, function() {
            if(player.gold >= 2500) {
                player.gold-=2500;
            }
            player.playerHat = "healingHelmet"
        }, ["Healer Helmet (2500 G)", 20]);
        fill(0, 0, 0, 0.5);
        button(canvas.width/8, canvas.height/4.44444/0.6, canvas.width - canvas.width/4, (canvas.height - 40)/8, function() {
            if(player.gold >= 4000) {
                player.gold-=4000;
            }
            player.playerHat = "soldierHelmet"
        }, ["Soldier Helmet (4000 G)", 20]);
    }
    // if holding a block
    if(this.inv[this.holding][1] === "block") {
        // displa the cost of the block
        fill(0, 0, 0, 0.5)
        rect(canvas.width - 110, 10, 100, 100, 0);
        fill(255, 255, 255);
        text("Wood: " + blockStats[this.inv[this.holding][0]].gives[0], canvas.width - 60, 10 + canvas.width/40, canvas.width/40);
        text("Stone: " + blockStats[this.inv[this.holding][0]].gives[1], canvas.width - 60, 10 + canvas.width/40 * 2, canvas.width/40);
        fill(255, 255, 255);
        text("Gold: " + blockStats[this.inv[this.holding][0]].gives[2], canvas.width - 60, 10 + canvas.width/40 * 3, canvas.width/40);
        text("Food: " + blockStats[this.inv[this.holding][0]].gives[1], canvas.width - 60, 10 + canvas.width/40 * 4, canvas.width/40);
    }
};
Player.prototype.clicks = function() {
    if(this.offset[1] < -1) {
        this.offset[1] = -1;
    }
    if(keys[81]) {
        if(this.offset[1] === 0) {
            this.offset[1] = -0.15;
        }
        this.offsetA[1] = -0.175;
    }
    if(clicked || keys[32] && keyPress <= 0) {
        keyPress = 30;
        switch(this.inv[this.holding][0]) {
            case "woodBlock":
                if(this.wood >= 10 && objects.length < 15) {
                    objects.push(new object(this.x + canvas.width/2 + cos(this.r + 3.5) * 50, this.y + canvas.height/2 + sin(this.r + 3.5) * 50, 0, "woodBlock"));
                    this.wood-=10;
                }
            break;
            case "stoneBlock":
                if(this.stone >= 20 && objects.length < 15) {
                    objects.push(new object(this.x + canvas.width/2 + cos(this.r + 3.5) * 50, this.y + canvas.height/2 + sin(this.r + 3.5) * 50, 0, "stoneBlock"));
                    this.stone-=20;
                }
            break;
            case "barracks":
                if(this.stone >= 250 && this.wood >= 300 && this.gold >= 250 && this.food >= 200 && objects.length < 15) {
                    objects.push(new object(this.x + canvas.width/2 + cos(this.r + 3.5) * 50, this.y + canvas.height/2 + sin(this.r + 3.5) * 50, 0, "barracks"));
                    this.wood-=300;
                    this.stone-=250;
                    this.gold-=250;
                    this.food-=200;
                    soldiers.push(new soldier(player.x + canvas.width/2, player.y + canvas.height/2, "milita"))
                }
            break;
            case "manor":
                if(this.stone >= 250 && this.wood >= 300 && this.gold >= 250 && this.food >= 200) {
                    objects.push(new object(this.x + canvas.width/2 + cos(this.r + 3.5) * 50, this.y + canvas.height/2 + sin(this.r + 3.5) * 50, 0, "manor"));
                    this.wood-=300;
                    this.stone-=250;
                    this.gold-=250;
                    this.food-=200;
                    soldiers.push(new soldier(player.x + canvas.width/2, player.y + canvas.height/2, "squire"))
                }
            break;
            case "axe":
                if(this.offset[0] <= 0) {
                    this.offset[0] = 0.1;
                    this.offsetA[0] = 0.1;
                }
            break;
            case "spear":
                if(this.offset[0] <= 0) {
                    this.offset[0] = 0.2;
                    this.offsetA[0] = 0.2;
                }
            break;
            case "sword":
                if(this.offset[0] <= 0) {
                    this.offset[0] = 0.15;
                    this.offsetA[0] = 0.15;
                }
            break;
            case "apple":
                if(this.hp < 100 && this.food >= 10) {
                    this.food-=10;
                    this.hp+=20;
                    this.hp = constrain(this.hp, 1, 100);
                }
            break;
            case "cookie":
                if(this.hp < 100 && this.food >= 20) {
                    this.food-=20;
                    this.hp+=40;
                    this.hp = constrain(this.hp, 1, 100);
                }
            break;
        }
    }
};
Player.prototype.reset = function() {
    // position of the player
    this.x = round(random(-4000, 4000));
    this.y = round(random(-4000, 4000));
    // acceleration of the player
    this.accelerationX = 0;
    this.accelerationY = 0;
    // rotation of the player
    this.r = atan2(canvas.height/2 - mouseY, canvas.width/2 - mouseX);
    this.color = [255, 200, 100];
    this.inv = [["axe", "wepon"], ["apple", "food"], ["barracks", "block"], ["woodBlock", "block"]];
    this.holding = 0;
    this.s = 10;
    this.stone = 0;
    this.wood = 0;
    this.food = 0;
    this.gold = 6000;
    this.offset = [0, 0];
    this.offsetA = [0, 0];
    this.weponSize = 10;
    this.weponLength = 30;
    this.weponDamage = 25;
    this.hp = 100;
    this.maxHp = 100;
    this.exp = 0;
    this.lvl = 1;
    this.armor = 0; // how much armor the player has
    // used for upgrading age, LVL Till end of upgrade, LVL so far
    this.upgrade = [1, 0.1];
    // toggle shop off and on
    this.showShop = false;
    // what hat the player is wearing
    this.playerHat = "none";
    // the name of the player
    this.playerName = "player";
};

// Particles
function particle(x, y, accelerationX, accelerationY, size, life, color) {
    // stats of the particle
    this.x = x;
    this.y = y;
    this.size = size;
    this.life = life;
    this.color = color;
    this.accelerationX = accelerationX;
    this.accelerationY = accelerationY;
};
particle.prototype.draw = function() {
    // draw the particle
    fill(this.color[0], this.color[1], this.color[2], (this.life)/255);
    ellipse(this.x - player.x, this.y - player.y, this.size, this.size, 0);
};
particle.prototype.update = function() {
    // update position
    this.x+=this.accelerationX;
    this.y+=this.accelerationY;
    this.accelerationX*=0.95;
    this.accelerationY*=0.95;
    
    // other updates
    this.life-=1;
};

// Object functions
function object(x, y, r, type) {
    this.x = x;
    this.y = y;
    this.r = r;
    this.type = type;
    this.size = blockStats[this.type].size;
    this.hp = blockStats[this.type].hp;
    this.gives = blockStats[this.type].gives
};
object.prototype.draw = function() {
    switch(this.type) {
        case "woodBlock":
            fill(150, 100, 0);
            rect(this.x - player.x, this.y - player.y, 25, 25, this.r);
        break;
        case "stoneBlock":
            fill(100, 100, 100);
            rect(this.x - player.x, this.y - player.y, 25, 25, this.r);
        break;
        case "barracks":
            fill(100, 75, 0);
            rect(this.x - player.x + 15, this.y - player.y + 15, 5, 20, 0);
            fill(255, 255, 255);
            for(var i = 0; i < 6; i+=1) {
                rect(this.x - player.x + 5 + Math.floor(i/3) * 12, this.y - player.y - 20 + i % 3 * 10 - Math.floor(i/3) * 10 + 25, 17, 5, -0.6 + Math.floor(i/3) * 1.2)
            }
            fill(0, 100, 255);
            for(var i = 0; i < 6; i+=1) {
                rect(this.x - player.x + 5 + Math.floor(i/3) * 12, this.y - player.y - 15 + i % 3 * 10 - Math.floor(i/3) * 10 + 25, 17, 5, -0.6 + Math.floor(i/3) * 1.2)
            }
        break;
        case "manor":
            fill(100, 75, 0);
            rect(this.x - player.x, this.y - player.y - 5, 30, 40);
            fill(125, 100, 25);
            for(var i = 0; i < 5; i+=1) {
                rect(this.x - player.x, this.y - player.y - 5 + i * 8, 30, 4);
            }
        break;
    }
};
object.prototype.collide = function(t, x, y) {
    if(rectToRect(this.x, this.y, this.size[0] + 10, this.size[1] + 10, t.x + x, t.y + y, 20, 20)) {
        t.x-=(this.x - (t.x + x))/20;
        t.y-=(this.y - (t.y + y))/20;
    }
    if(x > 0 && rectToRect(this.x, this.y, this.size[0] + 10, this.size[1] + 10, t.x + cos(t.r - 160) * t.weponLength + x, t.y + sin(t.r - 160) * t.weponLength + y, t.weponSize, t.weponSize)) {
        if(clicked || keys[32] && keyPress <= 10) {
            this.hp-=t.weponDamage;
        }
    }
};

// Tree functions
function tree() {
    this.x = round(random(-4000, 4000));
    this.y = round(random(-4000, 4000));
    this.s = round(random(50, 100));
    this.offset = [0, 0];
};
tree.prototype.draw = function() {
    // first layer
    fill(0, 150 + cos(this.x + this.y) * 9, 0);
    ellipse(this.x - player.x + this.offset[0], this.y - player.y + this.offset[1], this.s, this.s, 0);
    var x = this.x - player.x;
    var y = this.y - player.y;
    var s = this.s * 0.95;
    for(var i = 0; i < 10; i+=1) {
        rect(x + this.offset[0], y + this.offset[1], s, s, this.x + i);
    }
    // second layer
    fill(0, 140 + cos(this.x + this.y) * 9, 0)
    ellipse(this.x - player.x + this.offset[0], this.y - player.y + this.offset[1], this.s * 0.66, this.s * 0.66, 0);
    s = this.s * 0.61;
    for(var i = 0; i < 10; i+=1) {
        rect(x + this.offset[0], y + this.offset[1], s, s, this.x + i);
    }
    // third layer
    fill(0, 130 + cos(this.x + this.y) * 9, 0)
    ellipse(this.x - player.x + this.offset[0], this.y - player.y + this.offset[1], this.s * 0.33, this.s * 0.33, 0);
    s = this.s * 0.36;
    for(var i = 0; i < 10; i+=1) {
        rect(x + this.offset[0], y + this.offset[1], s, s, this.x + i);
    }
    this.offset[0] = lerp(this.offset[0], 0, 0.1);
    this.offset[1] = lerp(this.offset[1], 0, 0.1);
};
tree.prototype.collide = function(t, x, y) {
    if(x === undefined) {
        x = 0;
    }
    if(y === undefined) {
        y = 0;
    }
    while(dist(this.x - canvas.width/2 + x, this.y - canvas.height/2 + y, t.x, t.y) < this.s + 10) {
        var r = atan2((this.y - canvas.height/2) - t.y, (this.x - canvas.width/2) - t.x);
        t.x-=cos(r);
        t.y-=sin(r);
    }
    if(clicked || keys[32] && keyPress <= 10 && x === 0) {
        if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x + cos(t.r - 160) * t.weponLength, t.y + sin(t.r - 160) * t.weponLength) < t.weponSize + this.s + 10 && t.offset[0] > 0) {
            t.wood+=1;
            t.exp+=1;
            this.offset = [-(cos(t.r) * 5), -(sin(t.r) * 5)]
        }
    }
};

// Rock functions
function rock() {
    this.x = round(random(-4000, 4000));
    this.y = round(random(-4000, 4000));
    this.s = round(random(25, 50));
    this.offset = [0, 0];
};
rock.prototype.draw = function() {
    fill(100, 100, 100);
    heptagon(this.x - player.x + this.offset[0], this.y - player.y + this.offset[1], this.s + 5);
    this.offset[0] = lerp(this.offset[0], 0, 0.1);
    this.offset[1] = lerp(this.offset[1], 0, 0.1);
};
rock.prototype.collide = function(t, x, y) {
    if(x === undefined) {
        x = 0;
    }
    if(y === undefined) {
        y = 0;
    }
    while(dist(this.x - canvas.width/2 + x, this.y - canvas.height/2 + y, t.x, t.y) < this.s + 10) {
        var r = atan2((this.y - canvas.height/2) - t.y, (this.x - canvas.width/2) - t.x);
        t.x-=cos(r);
        t.y-=sin(r);
    }
    if(clicked || keys[32] && keyPress <= 10) {
        if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x + cos(t.r - 160) * t.weponLength, t.y + sin(t.r - 160) * t.weponLength) < t.weponSize + this.s + 10 && t.offset[0] > 0) {
            t.stone+=1;
            t.exp+=1;
            this.offset = [-(cos(t.r) * 5), -(sin(t.r) * 5)];
        }
    }
};

// Gold functions
function gold() {
    this.x = round(random(-4000, 4000));
    this.y = round(random(-4000, 4000));
    this.s = round(random(25, 50));
    this.offset = [0, 0];
};
gold.prototype.draw = function() {
    fill(255, 200, 0);
    heptagon(this.x - player.x, this.y - player.y, this.s + 5)
    this.offset[0] = lerp(this.offset[0], 0, 0.1);
    this.offset[1] = lerp(this.offset[1], 0, 0.1);
};
gold.prototype.collide = function(t, x, y) {
    if(x === undefined) {
        x = 0;
    }
    if(y === undefined) {
        y = 0;
    }
    while(dist(this.x - canvas.width/2 + x, this.y - canvas.height/2 + y, t.x, t.y) < this.s + 10) {
        var r = atan2((this.y - canvas.height/2 + y) - t.y, (this.x - canvas.width/2 + x) - t.x);
        t.x-=cos(r);
        t.y-=sin(r);
    }
    if(clicked || keys[32] && keyPress <= 10) {
        if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x + cos(t.r - 160) * t.weponLength, t.y + sin(t.r - 160) * t.weponLength) < t.weponSize + this.s + 10 && t.offset[0] > 0) {
            t.gold+=5;
            t.exp+=5;
            this.offset = [-(cos(t.r) * 5), -(sin(t.r) * 5)];
        }
    }
};

// Bush functions
function bush() {
    this.x = round(random(-4000, 4000));
    this.y = round(random(-3000, 3000));
    this.offset = [0, 0];
};
bush.prototype.draw = function() {
    fill(0, 150, 0);
    ellipse(this.x - player.x + this.offset[0], this.y - player.y, 20, 20, 0);
    ellipse(this.x - player.x + cos(this.x) * 10 + this.offset[0], this.y - player.y + sin(this.x) * 10 + this.offset[1], 15, 15, 0);
    ellipse(this.x - player.x - cos(this.y) * 10 + this.offset[0], this.y - player.y - sin(this.y) * 10 + this.offset[1], 15, 15, 0);
    ellipse(this.x - player.x + cos(this.x) * 10 + this.offset[0], this.y - player.y + cos(this.x) * 10 + this.offset[1], 15, 15, 0);
    ellipse(this.x - player.x - cos(this.y) * 10 + this.offset[0], this.y - player.y - sin(this.y) * 10 + this.offset[1], 15, 15, 0);
    fill(255, 0, 0)
    ellipse(this.x - player.x + cos(this.x) * 10 - 5 + this.offset[0], this.y - player.y + sin(this.x) * 10 + 5 + this.offset[1], 2, 2, 0);
    ellipse(this.x - player.x - cos(this.y) * 10 + 5 + this.offset[0], this.y - player.y - sin(this.y) * 10 - 5 + this.offset[1], 2, 2, 0);
    ellipse(this.x - player.x + cos(this.x) * 10 - 5 + this.offset[0], this.y - player.y + cos(this.x) * 10 - 5 + this.offset[1], 2, 2, 0);
    ellipse(this.x - player.x - cos(this.y) * 10 + 5 + this.offset[0], this.y - player.y - sin(this.y) * 10 + 5 + this.offset[1], 2, 2, 0);
    this.offset[0] = lerp(this.offset[0], 0, 0.1);
    this.offset[1] = lerp(this.offset[1], 0, 0.1);
};
bush.prototype.collide = function(t, x, y) {
    if(x === undefined) {
        x = 0;
    }
    if(y === undefined) {
        y = 0;
    }
    while(dist(this.x - canvas.width/2 + x, this.y - canvas.height/2 + y, t.x, t.y) < 30) {
        var r = atan2((this.y - canvas.height/2 + y) - t.y, (this.x - canvas.width/2 + x) - t.x);
        t.x-=cos(r);
        t.y-=sin(r);
    }
    if(clicked || keys[32] && keyPress <= 10) {
        if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x + cos(t.r - 160) * t.weponLength, t.y + sin(t.r - 160) * t.weponLength) < t.weponSize + 30 && t.offset[0] > 0) {
            t.food+=1;
            t.exp+=1;
            this.offset = [-(cos(t.r) * 5), -(sin(t.r) * 5)];
        }
    }
};

// Wolf functions
function wolf(x, y) {
    this.x = x;
    this.y = y;
    this.r = 0;
    this.ar = -0.05;
    this.t = 0;
    this.hp = 100;
    this.damage = 8;
    this.armor = 0;
};
wolf.prototype.draw = function() {
    fill(100, 100, 100)
    ellipse(this.x - player.x, this.y - player.y, 20, 15, this.r);
    fill(100, 100, 100)
    ellipse(this.x - player.x + cos(this.r) * 20, this.y - player.y + sin(this.r) * 20, 12.5, 12.5, this.r);
    fill(50, 50, 50);
    rect(this.x - player.x - 12.5, this.y - player.y + 20, 25, 5);
    fill(255, 0, 0);
    rect(this.x - player.x - 12.5, this.y - player.y + 20, this.hp/4, 5);
    fill(255, 255, 255);
    text("Wolf", this.x - player.x, this.y - player.y - 20, 20);
};
wolf.prototype.update = function() {
    this.t-=1;
    this.x+=cos(this.r);
    this.y+=sin(this.r);
    this.r -= random(0, this.ar);
    if(this.t <= 0) {
        if(random(0, 1) < 0.5) {
            this.ar = -0.05;
        } else {
            this.ar = 0.05;
        }
        this.t = round(random(50, 150))
    }
    if(this.x + canvas.width/2 > -200 && this.x + canvas.width/2 < 200) {
        this.y-=0.5;
    }
    this.x = constrain(this.x, -4000 - canvas.width/2, 4000 + canvas.width/2);
    this.y = constrain(this.y, -4000 - canvas.height/2, 4000 + canvas.height/2);
};
wolf.prototype.collide = function(t) {
    if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x, t.y) < canvas.width/2 + canvas.height/2) {
        this.r = atan2((player.y + canvas.height/2) - this.y, (player.x + canvas.width/2) - this.x);
        this.ar = 0;
        if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x, t.y) < 40) {
            while(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x, t.y) < 40) {
                var r = atan2((this.y - canvas.height/2) - t.y, (this.x - canvas.width/2) - t.x);
                t.x-=cos(r);
                t.y-=sin(r);
                t.hp-=constrain(this.damage - t.armor, 0, Infinity);
            }
            t.hp-=constrain(this.damage - t.armor, 0, Infinity);
            t.accelerationX = -cos(r) * 2;
            t.accelerationY = -sin(r) * 2;
        }
        if(clicked || keys[32] && keyPress <= 10) {
            if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x + cos(t.r - 160 + t.offset[0]) * t.weponLength, t.y + sin(t.r - 160 + t.offset[0]) * t.weponLength) < t.weponSize + 30 && t.offset[0] > 0) {
                this.hp-=constrain(t.weponDamage - this.armor, 0, Infinity);
            }
        }
    }
};

// Bull functions
function bull(x, y) {
    this.x = x;
    this.y = y;
    this.r = 0;
    this.ar = -0.05;
    this.t = 0;
    this.hp = 200;
    this.damage = 20;
    this.armor = 2;
};
bull.prototype.draw = function() {
    fill(191, 119, 10)
    ellipse(this.x - player.x, this.y - player.y, 35, 25, this.r);
    fill(181, 109, 0)
    ellipse(this.x - player.x + cos(this.r) * 20, this.y - player.y + sin(this.r) * 20, 25, 25, this.r);
    fill(50, 50, 50);
    rect(this.x - player.x - 25, this.y - player.y + 40, 50, 5);
    fill(255, 0, 0);
    rect(this.x - player.x - 25, this.y - player.y + 40, this.hp/4, 5);
    fill(255, 255, 255);
    text("Bull", this.x - player.x, this.y - player.y - 40, 20);
};
bull.prototype.update = function() {
    this.t-=1;
    this.x+=cos(this.r);
    this.y+=sin(this.r);
    this.r -= random(0, this.ar);
    if(this.t <= 0) {
        if(random(0, 1) < 0.5) {
            this.ar = -0.05;
        } else {
            this.ar = 0.05;
        }
        this.t = round(random(50, 150))
    }
    if(this.x + canvas.width/2 > -200 && this.x + canvas.width/2 < 200) {
        this.y-=0.5;
    }
    this.x = constrain(this.x, -4000 - canvas.width/2, 4000 + canvas.width/2);
    this.y = constrain(this.y, -4000 - canvas.height/2, 4000 + canvas.height/2);
};
bull.prototype.collide = function(t) {
    if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x, t.y) < canvas.width/2 + canvas.height/2) {
        this.r = atan2((player.y + canvas.height/2) - this.y, (player.x + canvas.width/2) - this.x);
        this.ar = 0;
        if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x, t.y) < 60) {
            while(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x, t.y) < 60) {
                var r = atan2((this.y - canvas.height/2) - t.y, (this.x - canvas.width/2) - t.x);
                t.x-=cos(r);
                t.y-=sin(r);
            }
            t.hp-=constrain(this.damage - t.armor, 0, Infinity);
            t.accelerationX = -cos(r) * 2;
            t.accelerationY = -sin(r) * 2;
        }
        if(clicked || keys[32] && keyPress <= 10) {
            if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x + cos(t.r - 160 + t.offset[0]) * t.weponLength, t.y + sin(t.r - 160 + t.offset[0]) * t.weponLength) < t.weponSize + 50 && t.offset[0] > 0) {
                this.hp-=constrain(t.weponDamage - this.armor, 0, Infinity);
            }
        }
    }
};

// Soldier functions
function soldier(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.r = 0;
    this.coolDown = 0;
    this.closest = 10000000;
    switch(this.type) {
        case "milita":
            this.maxHp = 100;
            this.hp = this.maxHp;
            this.damage = 25;
            this.reload = 20;
            this.armor = 0;
        break;
        case "squire":
            this.maxHp = 150;
            this.hp = this.maxHp;
            this.damage = 35;
            this.reload = 20;
            this.armor = 1;
        break;
    }
};
soldier.prototype.draw = function() {
    switch(this.type) {
        case "milita":
            fill(255, 200, 100);
            ellipse(this.x - player.x, (this.y - player.y), 10, 10, 0);
            ellipse((this.x - player.x) - cos(this.r + 0.5) * 17.5, (this.y - player.y) - sin(this.r + 0.5) * 17.5, 5, 5, 0);
            ellipse((this.x - player.x) - cos(this.r - 0.5) * 17.5, (this.y - player.y) - sin(this.r - 0.5) * 17.5, 5, 5, 0);
        break;
        case "squire":
            fill(175, 175, 175);
            ellipse(this.x - player.x, (this.y - player.y), 10, 10, 0);
            fill(255, 200, 100);
            ellipse((this.x - player.x) - cos(this.r + 0.5) * 17.5, (this.y - player.y) - sin(this.r + 0.5) * 17.5, 5, 5, 0);
            ellipse((this.x - player.x) - cos(this.r - 0.5) * 17.5, (this.y - player.y) - sin(this.r - 0.5) * 17.5, 5, 5, 0);
        break;
    }
    fill(50, 50, 50);
    rect((this.x - player.x) - 15, (this.y - player.y) + 15, 30, 5)
    fill(250, 0, 0);
    rect((this.x - player.x) - 15, (this.y - player.y) + 15, (30/this.maxHp) * this.hp, 5);
};
soldier.prototype.update = function() {
    // move towords the player
    if(dist(this.x, this.y, round(player.x + canvas.width/2), round(player.y + canvas.height/2)) > 50) {
        if(this.x < player.x + canvas.width/2) {
            this.x+=1;
        } else if(this.x > player.x + canvas.width/2) {
            this.x-=1;
        }
        if(this.y < player.y + canvas.height/2) {
            this.y+=1;
        } else if(this.y > player.y + canvas.height/2) {
            this.y-=1;
        }
    }
    // -1 to the attack cooldown
    this.coolDown-=1;
    // heal
    if(this.hp <= 100 && round(random(0, 100)) < 1) {
        this.hp+=20;
        this.hp = constrain(this.hp, 0, 100)
    }
    // if soldier is in the river
    if(this.x + canvas.width/2 > -200 && this.x + canvas.width/2 < 200) {
        // move the soldier
        this.y-=0.5;
    }
    // constrain the soldier
    this.x = constrain(this.x, -4000 + canvas.width/2, 4000 + canvas.width/2);
    this.y = constrain(this.y, -4000, 4000);
    // reset closest
    this.closest = 1000000;
};
soldier.prototype.collide = function(t, hurt) {
    var d = dist(this.x, this.y, t.x, t.y);
    var r = atan2((this.y - canvas.height/2) - t.y, (this.x - canvas.width/2) - t.x);
    if(d < this.closest) {
        if(hurt) {
            this.r = r - 180;
            this.closest = dist(this.x, this.y, t.x, t.y);
        }
    }
    if(d < 25) {
        t.x-=(this.x - t.x)/(dist(this.x, this.y, t.x, t.y));
        t.y-=(this.y - t.y)/(dist(this.x, this.y, t.x, t.y));
        this.x+=(this.x - t.x)/(dist(this.x, this.y, t.x, t.y));
        this.y+=(this.y - t.y)/(dist(this.x, this.y, t.x, t.y));
        if(hurt) {
            if(this.coolDown <= 0) {
                t.hp-=constrain(this.damage - t.armor, 0, Infinity);
                this.coolDown = this.reload;
            }
        }
    }
};

// Orc functions
function orc(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.r = 0;
    this.coolDown = 0;
    this.closest = 10000000;
    switch(this.type) {
        case "milita":
            this.maxHp = 100;
            this.hp = this.maxHp;
            this.damage = 25;
            this.reload = 20;
            this.armor = 0;
        break;
        case "squire":
            this.maxHp = 150;
            this.hp = this.maxHp;
            this.damage = 35;
            this.reload = 20;
            this.armor = 1;
        break;
    }
};
orc.prototype.draw = function() {
    switch(this.type) {
        case "milita":
            fill(0, 163, 14);
            ellipse(this.x - player.x, (this.y - player.y), 10, 10, 0);
            ellipse((this.x - player.x) - cos(this.r + 0.5) * 17.5, (this.y - player.y) - sin(this.r + 0.5) * 17.5, 5, 5, 0);
            ellipse((this.x - player.x) - cos(this.r - 0.5) * 17.5, (this.y - player.y) - sin(this.r - 0.5) * 17.5, 5, 5, 0);
        break;
        case "squire":
            fill(140, 140, 140);
            ellipse(this.x - player.x, (this.y - player.y), 10, 10, 0);
            fill(0, 163, 14);
            ellipse((this.x - player.x) - cos(this.r + 0.5) * 17.5, (this.y - player.y) - sin(this.r + 0.5) * 17.5, 5, 5, 0);
            ellipse((this.x - player.x) - cos(this.r - 0.5) * 17.5, (this.y - player.y) - sin(this.r - 0.5) * 17.5, 5, 5, 0);
        break;
    }
    fill(50, 50, 50);
    rect((this.x - player.x) - 15, (this.y - player.y) + 15, 30, 5)
    fill(250, 0, 0);
    rect((this.x - player.x) - 15, (this.y - player.y) + 15, (30/this.maxHp) * this.hp, 5);
};
orc.prototype.update = function() {
    // move towords the player
    if(dist(this.x, this.y, round(orcGeneral.x), round(orcGeneral.y)) > 50) {
        if(this.x < orcGeneral.x) {
            this.x+=1;
        } else if(this.x > orcGeneral.x) {
            this.x-=1;
        }
        if(this.y < orcGeneral.y) {
            this.y+=1;
        } else if(this.y > orcGeneral.y) {
            this.y-=1;
        }
    }
    // -1 to the attack cooldown
    this.coolDown-=1;
    // heal
    if(this.hp <= 100 && round(random(0, 100)) < 1) {
        this.hp+=20;
        this.hp = constrain(this.hp, 0, 100)
    }
    // if soldier is in the river
    if(this.x + canvas.width/2 > -200 && this.x + canvas.width/2 < 200) {
        // move the soldier
        this.y-=0.5;
    }
    // constrain the soldier
    this.x = constrain(this.x, -4000 + canvas.width/2, 4000 + canvas.width/2);
    this.y = constrain(this.y, -4000, 4000);
    // reset closest
    this.closest = 1000000;
};
orc.prototype.collide = function(t, hurt) {
    if(hurt && clicked || hurt && keys[32] && keyPress <= 10) {
        if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x + cos(t.r - 160 + t.offset[0]) * t.weponLength, t.y + sin(t.r - 160 + t.offset[0]) * t.weponLength) < t.weponSize + 30 && t.offset[0] > 0) {
            this.hp-=constrain(t.weponDamage - this.armor, 0, Infinity);
        }
    }
    
    // hurt the player
    if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x, t.y) < 25 || !hurt && dist(this.x, this.y, t.x, t.y) < 25) {
        t.x-=(this.x - t.x)/(dist(this.x, this.y, t.x, t.y));
        t.y-=(this.y - t.y)/(dist(this.x, this.y, t.x, t.y));
        this.x+=(this.x - t.x)/(dist(this.x, this.y, t.x, t.y));
        this.y+=(this.y - t.y)/(dist(this.x, this.y, t.x, t.y));
        if(hurt) {
            if(this.coolDown <= 0) {
                if(t.offset[1] === 0) {
                    t.hp-=constrain(this.damage - t.armor, 0, Infinity);
                    t.accelerationX = cos(atan2((player.y + canvas.height/2) - this.y, (player.x + canvas.width/2) - this.x));
                    t.accelerationY = sin(atan2((player.y + canvas.height/2) - this.y, (player.x + canvas.width/2) - this.x));
                } else {
                    t.accelerationX = cos(atan2((player.y + canvas.height/2) - this.y, (player.x + canvas.width/2) - this.x)) * 3;
                    t.accelerationY = sin(atan2((player.y + canvas.height/2) - this.y, (player.x + canvas.width/2) - this.x)) * 3;
                }
                this.coolDown = this.reload;
            }
        }
    }
    
};

// Orc genarel functions
function orcGenarel(x, y) {
    this.x = x;
    this.y = y;
    this.h
    this.r = 0;
    this.ar = 0;
    this.coolDown = 0;
    this.closest = 10000000;
    this.maxHp = 200;
    this.hp = this.maxHp;
    this.damage = 25;
    this.reload = 20;
    this.armor = 2;
};
orcGenarel.prototype.draw = function() {
    fill(0, 163, 14);
    ellipse(this.x - player.x, (this.y - player.y), 10, 10, 0);
    ellipse((this.x - player.x) - cos(this.r + 0.5) * 17.5, (this.y - player.y) - sin(this.r + 0.5) * 17.5, 5, 5, 0);
    ellipse((this.x - player.x) - cos(this.r - 0.5) * 17.5, (this.y - player.y) - sin(this.r - 0.5) * 17.5, 5, 5, 0);
    fill(50, 50, 50);
    rect((this.x - player.x) - 15, (this.y - player.y) + 15, 30, 5)
    fill(250, 0, 0);
    rect((this.x - player.x) - 15, (this.y - player.y) + 15, (30/this.maxHp) * this.hp, 5);
};
orcGenarel.prototype.update = function() {
    this.t-=1;
    this.x+=cos(this.r);
    this.y+=sin(this.r);
    this.r -= random(0, this.ar);
    if(this.t <= 0) {
        if(random(0, 1) < 0.5) {
            this.ar = -0.05;
        } else {
            this.ar = 0.05;
        }
        this.t = round(random(50, 150))
    }
    if(this.x + canvas.width/2 > -200 && this.x + canvas.width/2 < 200) {
        this.y-=0.5;
    }
    this.x = constrain(this.x, -4000 - canvas.width/2, 4000 + canvas.width/2);
    this.y = constrain(this.y, -4000 - canvas.height/2, 4000 + canvas.height/2);
    this.coolDown-=1;
    // heal
    if(this.hp <= 100 && round(random(0, 100)) < 10) {
        this.hp+=40;
        this.hp = constrain(this.hp, 0, 100)
    }
};
orcGenarel.prototype.collide = function(t, hurt) {
    if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x, t.y) < canvas.width/2 + canvas.height/2) {
        this.r = atan2((player.y + canvas.height/2) - this.y, (player.x + canvas.width/2) - this.x);
        this.ar = 0;
        if(clicked || keys[32] && keyPress <= 10) {
            if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x + cos(t.r - 160 + t.offset[0]) * t.weponLength, t.y + sin(t.r - 160 + t.offset[0]) * t.weponLength) < t.weponSize + 30 && t.offset[0] > 0) {
                this.hp-=constrain(t.weponDamage - this.armor, 0, Infinity);
            }
        }
        if(dist(this.x - canvas.width/2, this.y - canvas.height/2, t.x, t.y) < 25) {
            t.x-=(this.x - t.x)/(dist(this.x, this.y, t.x, t.y));
            t.y-=(this.y - t.y)/(dist(this.x, this.y, t.x, t.y));
            this.x+=(this.x - t.x)/(dist(this.x, this.y, t.x, t.y));
            this.y+=(this.y - t.y)/(dist(this.x, this.y, t.x, t.y));
            if(hurt) {
                if(this.coolDown <= 0) {
                    if(t.offset[1] === 0) {
                        t.hp-=constrain(this.damage - t.armor, 0, Infinity);
                        t.accelerationX = cos(atan2((player.y + canvas.height/2) - this.y, (player.x + canvas.width/2) - this.x));
                        t.accelerationY = sin(atan2((player.y + canvas.height/2) - this.y, (player.x + canvas.width/2) - this.x));
                    } else {
                        t.accelerationX = cos(atan2((player.y + canvas.height/2) - this.y, (player.x + canvas.width/2) - this.x)) * 3;
                        t.accelerationY = sin(atan2((player.y + canvas.height/2) - this.y, (player.x + canvas.width/2) - this.x)) * 3;
                    }
                    this.coolDown = this.reload;
                }
            }
        }
    }
};

// Map functions
function Map() {
    this.frameRate = 0;
};
Map.prototype.draw = function() {
    // snow boime
    fill(240, 240, 240);
    rect(-4000 - player.x + canvas.width, -4000 - player.y, 8000, 1000 + canvas.height/2);
    // desert boime
    fill(235, 213, 52);
    rect(-4000 - player.x + canvas.width, 3000 - player.y + canvas.height/2, 8000, 1000 + canvas.height/2);
    // draw the beach
    fill(247, 225, 59);
    rect(-210 - player.x + canvas.width/2, -4000 - player.y, 420, 8000 + canvas.height * 2)
    // grid pattern
    grid();
    // draw the river
    fill(52, 146, 235);
    rect(-200 - player.x + canvas.width/2 + cos(this.frameRate/20), -4000 - player.y, 400 + sin(this.frameRate/20) * 2, 8000 + canvas.height * 2);
};
Map.prototype.update = function() {
    // if the player is in the river
    if(player.x > -200 && player.x < 200) {
        // move the player
        player.y-=0.5;
    }
    // add one to the frameRate counter
    this.frameRate+=1;
};

// initiate player
var player = new Player();

// initiate map
var map = new Map();

// Tree spawning
for(var i = 0; i < 100; i+=1) {
    trees.push(new tree());
}

// Rock spawning
for(var i = 0; i < 100; i+=1) {
    rocks.push(new rock());
}

// Bush spawning
for(var i = 0; i < 150; i+=1) {
    bushes.push(new bush());
}

// Gold spawning
for(var i = 0; i < 50; i+=1) {
    golds.push(new gold());
}

// Wolf spawning
for(var i = 0; i < 20; i+=1) {
    wolves.push(new wolf(round(random(-4000, -3000)), round(random(-4000, -3000))));
    //wolves.push(new wolf(player.x, player.y));
}

// Bull spawning
for(var i = 0; i < 20; i+=1) {
    bulls.push(new bull(round(random(4000, 3000)), round(random(4000, 3000))));
    //bulls.push(new bull(player.x + round(random(-100, 600)), player.y + round(random(-100 ,600))));
}

// Orc spawning
orcGeneral = new orcGenarel(player.x, player.y);
for(var i = 0; i < baisedRandom(); i+=1) {
    orcs.push(new orc(orcGeneral.x + round(random(-10, 10)), orcGeneral.y - 100 + round(random(-10, 10)), randomGuy()));
}

// button function
function button(x, y, width, height, does, txt) {
    rect(x, y, width, height, 0);
    fill(255, 255, 255);
    text(txt[0], x + width/2, y + height/2 + txt[1]/2 - 4, txt[1]);
    if(mouseX > x && mouseY > y && mouseX < x + width && mouseY < y + height && clicked) {
        does();
    }
};

// menu function
function menu() {
    textAlign("center");
    // the background {
    grid();
    fill(0, 0, 0, 0.5);
    rect(0, 0, canvas.width, canvas.height, 0);
    // }
    // enter game box {
    fill(100, 100, 100);
    rect(canvas.width/2 - canvas.width/10/0.7, canvas.height/4 - canvas.height/35, canvas.width/5/0.7, canvas.width/9 + canvas.height/25 * 2);
    fill(255, 255, 255);
    rect(canvas.width/2 - canvas.width/10/0.7, canvas.height/4 - canvas.height/25, canvas.width/5/0.7, canvas.width/9 + canvas.height/25 * 2);
    fill(150, 150, 150);
    rect(canvas.width/2 - canvas.width/7.5, canvas.height/4.09, canvas.width/3.75, canvas.width/20, 0);
    fill(0, 0, 0);
    text(player.playerName, canvas.width/2, canvas.height/3.4, canvas.width/30);
    // allow players to type name {
    for(var i = 0; i < alphebet.length; i+=1) {
        if(keys[65 + i] && keyPress <= 0) {
            player.playerName+=alphebet[i];
            keyPress = 30;
        }
    }
    if(keys[8] && keyPress <= 0) {
        keyPress = 60;
        player.playerName = player.playerName.slice(0, player.playerName.length - 1);
    }
    // }
    fill(0, 200, 0);
    button(canvas.width/2 -  canvas.width/10, canvas.height/3, canvas.width/5, canvas.width/15, function() {
        scene = "game";
    }, ["Enter Game", canvas.width/30]);
    // }
    // change skin { 
    fill(100, 100, 100);
    rect(canvas.width/5 - canvas.width/10/0.7, canvas.height/4 - canvas.height/35, canvas.width/5/0.7, canvas.width/9);
    fill(255, 255, 255);
    rect(canvas.width/5 - canvas.width/10/0.7, canvas.height/4 - canvas.height/25, canvas.width/5/0.7, canvas.width/9);
    fill(0, 0, 0);
    text("Change Skin", canvas.width/5, canvas.height/3.9 + canvas.height/100, canvas.width/25);
    // Light skin color
    fill(255, 200, 100);
    button(canvas.width/13 + canvas.width/20 * 0, canvas.height/3.5 + canvas.height/100, canvas.width/25, canvas.width/25, function() {
        player.color = [255, 200, 100];
    }, ["", 100]);
    // Dark skin color
    fill(190, 150, 50);
    button(canvas.width/13 + canvas.width/20 * 1, canvas.height/3.5 + canvas.height/100, canvas.width/25, canvas.width/25, function() {
        player.color = [190, 150, 50];
    }, ["", 100]);
    // Red skin color
    fill(255, 0, 0);
    button(canvas.width/13 + canvas.width/20 * 2, canvas.height/3.5 + canvas.height/100, canvas.width/25, canvas.width/25, function() {
        player.color = [255, 0, 0];
    }, ["", 100]);
    // Blue skin color
    fill(0, 0, 255);
    button(canvas.width/13 + canvas.width/20 * 3, canvas.height/3.5 + canvas.height/100, canvas.width/25, canvas.width/25, function() {
        player.color = [0, 0, 255];
    }, ["", 100]);
    // Black skin color
    fill(0, 0, 0);
    button(canvas.width/13 + canvas.width/20 * 4, canvas.height/3.5 + canvas.height/100, canvas.width/25, canvas.width/25, function() {
        player.color = [0, 0, 0];
    }, ["", 100]);
    // }
    // game title {
    fill(255, 255, 255);
    fill(0, 0, 0);
    text("Surviv", canvas.width/2, canvas.height/6, canvas.width/10);
    fill(255, 255, 255);
    text("Surviv", canvas.width/2 + 3, canvas.height/6 - 3, canvas.width/10);
    // }
};

// do every thing
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    switch(scene) {
        case "menu":
            menu();
        break;
        case "game":
            // update and draw the map
            map.draw();
            map.update();
            
            // update and draw the player
            player.update();
            player.draw();
            player.clicks();
            
            // update and draw the orc general
            orcGeneral.update();
            orcGeneral.draw();
            orcGeneral.collide(player, true);
            
            // loop through the trees
            for(var i = 0; i < trees.length; i+=1) {
                if(player.x >= trees[i].x - canvas.width - trees[i].s - 25 && player.x <= trees[i].x + canvas.width + trees[i].s + 25 && player.y >= trees[i].y - canvas.height - trees[i].s && player.y <= trees[i].y + canvas.height + trees[i].s + 25) {
                    entitys+=1;
                    trees[i].draw();
                    trees[i].collide(player);
                    for(var j = 0; j < wolves.length; j+=1) {
                        trees[i].collide(wolves[j], canvas.width/2, canvas.height/2);
                    }
                    for(var o = 0; o < soldiers.length; o+=1) {
                        trees[i].collide(soldiers[o], canvas.width/2, canvas.height/2)
                    }
                    for(var orcy = 0; orcy < orcs.length; orcy+=1) {
                        trees[i].collide(orcs[orcy], canvas.width/2, canvas.height/2)
                    }
                }
            }
            
            // loop through the rocks
            for(var i = 0; i < rocks.length; i+=1) {
                if(player.x >= rocks[i].x - canvas.width - rocks[i].s - 25 && player.x <= rocks[i].x + canvas.width + rocks[i].s + 25 && player.y >= rocks[i].y - canvas.height - rocks[i].s && player.y <= rocks[i].y + canvas.height + rocks[i].s + 25) {
                    entitys+=1;
                    rocks[i].draw();
                    rocks[i].collide(player)
                    for(var j = 0; j < wolves.length; j+=1) {
                        rocks[i].collide(wolves[j], canvas.width/2, canvas.height/2);
                    }
                    for(var o = 0; o < soldiers.length; o+=1) {
                        rocks[i].collide(soldiers[o], canvas.width/2, canvas.height/2)
                    }
                    for(var orcy = 0; orcy < orcs.length; orcy+=1) {
                        rocks[i].collide(orcs[orcy], canvas.width/2, canvas.height/2)
                    }
                }
            }
            
            // loop through the gold
            for(var i = 0; i < golds.length; i+=1) {
                if(player.x >= golds[i].x - canvas.width - golds[i].s - 25 && player.x <= golds[i].x + canvas.width + golds[i].s + 25 && player.y >= golds[i].y - canvas.height - golds[i].s && player.y <= golds[i].y + canvas.height + golds[i].s + 25) {
                    entitys+=1;
                    golds[i].draw();
                    golds[i].collide(player)
                    for(var j = 0; j < wolves.length; j+=1) {
                        golds[i].collide(wolves[j], canvas.width/2, canvas.height/2);
                    }
                    for(var o = 0; o < soldiers.length; o+=1) {
                        golds[i].collide(soldiers[o], canvas.width/2, canvas.height/2)
                    }
                    for(var orcy = 0; orcy < orcs.length; orcy+=1) {
                        golds[i].collide(orcs[orcy], canvas.width/2, canvas.height/2)
                    }
                }
            }
            
            // loop though the bushes
            for(var i = 0; i < bushes.length; i+=1) {
                if(player.x >= bushes[i].x - canvas.width - 20 && player.x < bushes[i].x + 20 && player.y >= bushes[i].y - 10 - canvas.height  && player.y <= bushes[i].y + 10) {
                    entitys+=1;
                    bushes[i].draw();
                    for(var j = 0; j < wolves.length; j+=1) {
                        bushes[i].collide(wolves[j], canvas.width/2, canvas.height/2);
                    }
                    for(var o = 0; o < soldiers.length; o+=1) {
                        bushes[i].collide(soldiers[o], canvas.width/2, canvas.height/2)
                    }
                    for(var orcy = 0; orcy < orcs.length; orcy+=1) {
                        bushes[i].collide(orcs[orcy], canvas.width/2, canvas.height/2)
                    }
                    bushes[i].collide(player)
                }
            }
            
            // loop through the objects
            for(var i = 0; i < objects.length; i+=1) {
                // if the object is on screen
                if(player.x >= objects[i].x - canvas.width - 37.5 && player.x <= objects[i].x + canvas.width + 37.5 && player.y >= objects[i].y - canvas.height - 12.5 && player.y <= objects[i].y + canvas.height + 37.5) {
                    // add one to the entity counter
                    entitys+=1;
                    // do the functions
                    objects[i].draw();
                    objects[i].collide(player, canvas.width/2, canvas.height/2);
                    // collision with the wolves
                    for(var j = 0; j < wolves.length; j+=1) {
                        objects[i].collide(wolves[j], 0, 0);
                    }
                    for(var o = 0; o < soldiers.length; o+=1) {
                        objects[i].collide(soldiers[o], 0, 0);
                    }
                    for(var orcy = 0; orcy < orcs.length; orcy+=1) {
                        objects[i].collide(orcs[orcy], 0, 0);
                    }
                    // if the objects helath is less then 0
                    if(objects[i].hp <= 0) {
                        // returns the matierials the player used to build the object
                        player.wood+=objects[i].gives[0];
                        player.stone+=objects[i].gives[1];
                        player.gold+=objects[i].gives[2];
                        player.food+=objects[i].gives[3];
                        // destroys the object
                        objects.splice(i, 1);
                    }
                }
            }
            
            // loop through wolves
            for(var i = 0; i < wolves.length; i+=1) {
                if(player.x >= wolves[i].x - canvas.width - 37.5 && player.x <= wolves[i].x + 10 && player.y >= wolves[i].y - canvas.height - 12.5 && player.y <= wolves[i].y + 10) {
                    entitys+=1;
                    wolves[i].draw();
                    wolves[i].collide(player);
                    if(wolves[i].hp <= 0) {
                        wolves.splice(i, 1);
                        player.food+=200;
                        player.exp+=100;
                        player.gold+=200;
                    }
                }
                wolves[i].update();
            }
            
            // loop through bulls
            for(var i = 0; i < bulls.length; i+=1) {
                if(player.x >= bulls[i].x - canvas.width - 37.5 && player.x <= bulls[i].x + 10 && player.y >= bulls[i].y - canvas.height - 12.5 && player.y <= bulls[i].y + 10) {
                    entitys+=1;
                    bulls[i].draw();
                    bulls[i].collide(player);
                    if(bulls[i].hp <= 0) {
                        bulls.splice(i, 1);
                        player.food+=200;
                        player.exp+=200;
                        player.gold+=500;
                    }
                }
                bulls[i].update();
            }
            
            // loop through soldiers
            for(var i = 0; i < soldiers.length; i+=1) {
                // do the soldiers functions
                soldiers[i].draw();
                soldiers[i].update();
                soldiers[i].collide(orcGeneral);
                // collide and hurt wolves
                for(var j = 0; j < wolves.length; j+=1) {
                    soldiers[i].collide(wolves[j], true);
                }
                // collide with other soldiers
                for(var o = 0; o < soldiers.length; o+=1) {
                    if(i !== o) {
                        soldiers[i].collide(soldiers[o]);
                    }
                }
                // loop and damge the orcs
                for(var orcy = 0; orcy < orcs.length; orcy+=1) {
                    soldiers[i].collide(orcs[orcy], true);
                }
                if(soldiers[i].hp <= 0) {
                    soldiers.splice(i, 1);
                }
            }
            
            // loop through the orcs
            for(var i = 0; i < orcs.length; i+=1) {
                // do the orc functions
                orcs[i].draw();
                orcs[i].update();
                // loop and collide with other orcs
                for(var o = 0; o < orcs.length; o+=1) {
                    if(i !== o) {
                        orcs[i].collide(orcs[o], false);
                    }
                }
                orcs[i].collide(player, true);
                if(orcs[i].hp < 0) {
                    orcs.splice(i, 1);
                }
            }
            
            // loop throught all the particles
            for(var i = 0; i < particles.length; i+=1) {
                particles[i].draw();
                particles[i].update();
                if(particles[i].life <= 1) {
                    particles.splice(i, 1);
                }
            }
            
            // show the ui and stats
            player.ui();
            fill(255, 255, 255);
            text("Position: " + round(player.x) + ", " + round(player.y), 65, 15, 12);
            text("hp: " + round(player.hp) + "/" + "100", 65, 30, 12)
            text("Entitys: " + round(entitys), 65, 45, 12);
            
            // if the player is dead
            if(player.hp <= 0) {
                player.reset();
                wolves = [];
                objects = [];
                scene = "menu";
            }
            
            // if the orc general is dead
            if(orcGeneral.hp <= 0) {
                orcs = [];
                // Orc spawning
                orcGeneral = new orcGenarel(round(random(-4000, 4000)), round(random(-4000, 4000)))
                for(var i = 0; i < baisedRandom(); i+=1) {
                    orcs.push(new orc(orcGeneral.x + round(random(-10, 10)), orcGeneral.y - 100 + round(random(-10, 10)), randomGuy()));
                }
            }
            // mini map
            fill(0, 0, 0, 0.5);
            rect(10, canvas.height - 110, 100, 100);
            rect(4000 - player.x, -4000 - player.y - canvas.height, 8000, canvas.height);
            fill(255, 255, 255);
            ellipse(60 + (100/8000) * player.x, canvas.height - 60 + (100/8000) * player.y, 2, 2, 0);
            
            // loop trough the soldiers
            for(var i = 0; i < soldiers.length; i+=1) {
                fill(255, 255, 255);
                ellipse(60 + (100/8000) * soldiers[i].x, canvas.height - 60 + (100/8000) * soldiers[i].y, 2, 2, 0);
            }
            
            // loop through the objects
            for(var i = 0; i < objects.length; i+=1) {
                fill(255, 255, 255);
                rect(60 + (100/8000) * objects[i].x - 5, canvas.height - 60 + (100/8000) * objects[i].y - 5, 2, 2, 0);
            }
        break;
    }
    clicked = false;
    keyPress-=1;
    // respawn wolves
    if(wolves.length < 20) {
        wolves.push(new wolf(round(random(-4000, -3000)), round(random(-4000, -3000))));
    }
    // respawn bulls
    if(bulls.length < 20) {
        bulls.push(new bull(round(random(4000, 3000)), round(random(4000, 3000))));
    }
    entitys = 0;
};
draw();
start();
    </script>
</body>
</html>
